#!/usr/bin/env python3

import codecs
import json
import copy
import os
import os.path as op
import sys
import subprocess as sp
import shutil
import pprint
import logging

import flywheel

# Gear basics
FLYWHEEL_BASE = '/flywheel/v0'
MANIFEST_FILE = op.join(FLYWHEEL_BASE, 'manifest.json')
CONFIG_FILE   = op.join(FLYWHEEL_BASE, 'config.json')
INPUT_DIR     = op.join(FLYWHEEL_BASE, 'input')
OUTPUT_DIR    = op.join(FLYWHEEL_BASE, 'output')
COMMAND       = 'mriqc'
RESULT        = 'derivatives'


# Set log name using versioned gear name
with open(MANIFEST_FILE, 'r') as f:
    manifest = json.load(f)
log = logging.getLogger(manifest['custom']['gear-builder']['image'])


def download_bids(context):
    """ Download all files from the session in BIDS format
        bids_path will point to the local BIDS folder
        This creates a simiple dataset_description.json if
        one did not get downloaded.
    """

    # the usual BIDS path:
    bids_path = op.join(FLYWHEEL_BASE, 'work/bids')

    # If BIDS was already downloaded, don't do it again
    # (this saves time when developing locally)
    if not op.isdir(bids_path):

        bids_path = context.download_session_bids()

        # make sure dataset_description.json exists
        required_file = bids_path+'/dataset_description.json'
        if not op.exists(required_file):
            log.info(f' Creating missing {required_file}.')
            the_stuff = {
                "Acknowledgements": "",
                "Authors": [],
                "BIDSVersion": "1.2.0",
                "DatasetDOI": "",
                "Funding": "",
                "HowToAcknowledge": "",
                "License": "",
                "Name": "tome",
                "ReferencesAndLinks": [],
                "template": "project"
            }
            with open(required_file, 'w') as outfile:
                json.dump(the_stuff, outfile)
        else:
            log.info(f'{required_file} exists.')

        log.info(f' BIDS was downloaded into {bids_path}')

    else:
        log.info(f' Using existing BIDS path {bids_path}')

    return bids_path


def run_bids_validation(config, bids_path, environ):
    """ Run BIDS Validator on bids_path
        Install BIDS Validator into container with: 
            RUN npm install -g bids-validator
        This prints a summary of files that are valid,
        and then lists errors and warnings.
        Then it exits if abort-on-bids-error is set and
        if there are any errors.
        The config MUST contain both of these:
            run-bids-validation
            abort-on-bids-error
    """

    if config['run-bids-validation']:

        command = ['bids-validator','--verbose','--json',bids_path]
        log.info(' Command:'+' '.join(command))
        result = sp.run(command, stdout=sp.PIPE, stderr=sp.PIPE,
                        universal_newlines=True, env=environ)
        log.info(' bids-validator return code: '+str(result.returncode))
        #log.info(result.stdout)
        bids_output = json.loads(result.stdout)

        log.info(' bids-validator results:\n\nValid BIDS files summary:\n' + \
                 pprint.pformat(bids_output['summary'],indent=8)+'\n')

        num_bids_errors = len(bids_output['issues']['errors'])

        for err in bids_output['issues']['errors']:
            err_msg = err['reason']+'\n'
            for ff in err['files']:
                if ff["file"]:
                    err_msg += f'       {ff["file"]["relativePath"]}\n'
            log.error(' '+err_msg)

        for warn in bids_output['issues']['warnings']:
            warn_msg = warn['reason']+'\n'
            for ff in warn['files']:
                if ff["file"]:
                    warn_msg += f'       {ff["file"]["relativePath"]}\n'
            log.warning(' '+warn_msg)

        if config['abort-on-bids-error']:
            if num_bids_errors > 0:
                log.critical(f' {num_bids_errors} BIDS validation errors '+\
                              'were detected: NOT running mriqc.')
                os.sys.exit(1)

    # Don't pass these arguments on, the are used up
    del config['run-bids-validation']
    del config['abort-on-bids-error']


def Build_Params(config):
    Params = {}
    for key in config.keys():
        # Use only those boolean values that are True
        if type(config[key]) == bool:
            if config[key]:
                Params[key] = True
        else:
            if len(key) == 1:
                Params[key] = config[key]
            else:
                if config[key] != 0:  # if zero, skip and use defaults
                    Params[key] = config[key]
    return Params


def Validate_Params(Params):
    """
    Validate settings of the Parameters constructed.
    Gives warnings for possible settings that could result in bad results.
    Gives errors (and raises exceptions) for settings that are violations 
    """

    # Test for input existence
    #if not op.exists(Params['i']):
    #    raise Exception('Input File Not Found')

    # Tests for specific problems/interactions that can raise expections or log warnings
    #if ('betfparam' in Params) and ('nononlinreg' in Params):
    #    if(Params['betfparam']>0.0):
    #        raise Exception('For betfparam values > zero, nonlinear registration is required.')

    #if ('s' in Params.keys()):
    #    if Params['s']==0:
    #        log.warning(' The value of ' + str(Params['s'] + ' for -s may cause a singular matrix'))


def BuilCommandList(command, ParamList, bids_path):
    """
    command is a list of prepared commands
    ParamList is a dictionary of key:value pairs to be put into the command list as such ("-k value" or "--key=value")
    """

    command = [COMMAND]

    for key in ParamList.keys():
        # Single character command-line parameters are preceded by a single '-'
        if len(key) == 1:
            command.append('-' + key)
            if len(str(ParamList[key]))!=0:
                command.append(str(ParamList[key]))
        # Multi-Character command-line parameters are preceded by a double '--'
        else:
            # If Param is boolean and true include, else exclude
            if type(ParamList[key]) == bool:
                if ParamList[key]:
                    command.append('--' + key)
            else:
                # If Param not boolean, but without value include without value
                # (e.g. '--key'), else include value (e.g. '--key=value')
                if len(str(ParamList[key])) == 0:
                    command.append('--' + key)
                else:
                    command.append('--' + key + '=' + str(ParamList[key]))
        if key == 'verbose': # handle a 'count' argparse argument
            # replace "--verbose=vvv' with '-vvv'
            command[-1] = '-'+ParamList[key]

    # add positional arguments
    command.append(bids_path)
    command.append(OUTPUT_DIR)
    command.append('participant')
    log.info(' Command:'+' '.join(command))

    return command


def main(context):

    config = context.config

    log.setLevel(getattr(logging, config['log_level']))

    # grab environment for gear
    with open('/tmp/gear_environ.json', 'r') as f:
        environ = json.load(f)

    try:

        bids_path = download_bids(context)

        run_bids_validation(config, bids_path, environ)

        # Build a parameter dictionary specific for COMMAND
        params = Build_Params(config)

        # Validate the COMMAND parameter dictionary
        # Raises Exception on fail
        Validate_Params(params)

        # Build command-line string for subprocess to execute
        command = BuilCommandList(params, bids_path)

        result = sp.run(command, stdout=sp.PIPE, stderr=sp.PIPE,
                        universal_newlines=True, env=environ)

        log.info(' '+result.returncode)
        log.info(' '+result.stdout)

        if result.returncode != 0:
            log.error(' The command:\n ' +
                  ' '.join(command) +
                  '\nfailed. See log for debugging.')
            log.error(' '+result.stderr)
            os.sys.exit(result.returncode)
        else:
            log.info("' '+Commands successfully executed!")
            os.sys.exit(0)

    except Exception as e:
        #log.error(e)
        log.exception('Ruh row, there is a problem.')
        os.sys.exit(1)

    finally:
        # Cleanup, move all results to the output directory
        # Unless otherwise specified, zip entire results and delete directory
        os.chdir(OUTPUT_DIR)
        #if the output/RESULT path exists, zip it regardless of exit status
        #if op.exists('/flywheel/v0/output/RESULT/'):
        #    log.info('Zipping /flywheel/v0/output/RESULT/ directory.')
        #    command1 = ['zip', 'results.anat.zip', 'RESULT']
        #    result1 = sp.run(command1, stdout=sp.PIPE, stderr=sp.PIPE)
        #    command2 = ['rm', '-rf', '/flywheel/v0/output/RESULT/']
        #    result2 = sp.run(command2, stdout=sp.PIPE, stderr=sp.PIPE)
        #else:
        #    log.info('No results directory, /flywheel/v0/output/RESULT, to zip.')

if __name__ == '__main__':
    with flywheel.GearContext() as context:
        context.init_logging()
        context.log_config()
        main(context)

#log.info("Exiting early.")
#os.sys.exit(0)
        
# vi:set autoindent ts=4 sw=4 expandtab : See Vim, :help 'modeline'
