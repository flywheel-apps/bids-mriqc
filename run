#!/usr/bin/env python3

import codecs
import json
import copy
import os
import os.path as op
import sys
import subprocess as sp
import shutil
import pprint
import logging
import psutil
import glob
import csv
import datetime

import flywheel

# Gear basics
FLYWHEEL_BASE = '/flywheel/v0'
MANIFEST_FILE = op.join(FLYWHEEL_BASE, 'manifest.json')
CONFIG_FILE = op.join(FLYWHEEL_BASE, 'config.json')
INPUT_DIR = op.join(FLYWHEEL_BASE, 'input')
OUTPUT_DIR = op.join(FLYWHEEL_BASE, 'output')
WORK_DIR = op.join(FLYWHEEL_BASE, 'work')
COMMAND = 'mriqc'
RESULT = 'derivatives'

LOG = logging.getLogger('flywheel/bids-mriqc')


def download_bids():
    """ Download all files from the session in BIDS format
        bids_path will point to the local BIDS folder
        This creates a simiple dataset_description.json if
        one did not get downloaded.
    """

    # the usual BIDS path:
    bids_path = op.join(FLYWHEEL_BASE, 'work/bids')

    # If BIDS was already downloaded, don't do it again
    # (this saves time when developing locally)
    if not op.isdir(bids_path):

        bids_path = context.download_session_bids()
        # Use the following command instead (after core is updated with a fix
        # for it) because it will return the existing dataset_description.json
        # file and does not download scans that mriqc does not handle.
        # bids_path = context.download_project_bids(folders=['anat', 'func'])

        # make sure dataset_description.json exists
        # Is there a way to download the dataset_description.json file from the 
        # platform instead of creating a generic stub?
        required_file = bids_path + '/dataset_description.json'
        if not op.exists(required_file):
            LOG.info(f' Creating missing {required_file}.')
            the_stuff = {
                "Acknowledgements": "",
                "Authors": [],
                "BIDSVersion": "1.2.0",
                "DatasetDOI": "",
                "Funding": "",
                "HowToAcknowledge": "",
                "License": "",
                "Name": "tome",
                "ReferencesAndLinks": [],
                "template": "project"
            }
            with open(required_file, 'w') as outfile:
                json.dump(the_stuff, outfile)
        else:
            LOG.info(f'{required_file} exists.')

        LOG.info(f' BIDS was downloaded into {bids_path}')

    else:
        LOG.info(f' Using existing BIDS path {bids_path}')

    return bids_path


def run_bids_validation(config, bids_path, environ):
    """ Run BIDS Validator on bids_path
        Install BIDS Validator into container with: 
            RUN npm install -g bids-validator
        This prints a summary of files that are valid,
        and then lists errors and warnings.
        Then it exits if gear-abort-on-bids-error is set and
        if there are any errors.
        The config MUST contain both of these:
            gear-run-bids-validation
            gear-abort-on-bids-error
    """

    if config['gear-run-bids-validation']:

        command = ['bids-validator', '--verbose', '--json', bids_path]
        LOG.info(' Command:' + ' '.join(command))
        result = sp.run(command, stdout=sp.PIPE, stderr=sp.PIPE,
                        universal_newlines=True, env=environ)
        LOG.info(' bids-validator return code: ' + str(result.returncode))
        bids_output = json.loads(result.stdout)

        # show summary of valid BIDS stuff
        LOG.info(' bids-validator results:\n\nValid BIDS files summary:\n' +
                 pprint.pformat(bids_output['summary'], indent=8) + '\n')

        num_bids_errors = len(bids_output['issues']['errors'])

        # show all errors
        for err in bids_output['issues']['errors']:
            err_msg = err['reason'] + '\n'
            for ff in err['files']:
                if ff["file"]:
                    err_msg += f'       {ff["file"]["relativePath"]}\n'
            LOG.error(' ' + err_msg)

        # show all warnings
        for warn in bids_output['issues']['warnings']:
            warn_msg = warn['reason'] + '\n'
            for ff in warn['files']:
                if ff["file"]:
                    warn_msg += f'       {ff["file"]["relativePath"]}\n'
            LOG.warning(' ' + warn_msg)

        if config['gear-abort-on-bids-error'] and num_bids_errors > 0:
            LOG.critical(f' {num_bids_errors} BIDS validation errors ' +
                         'were detected: NOT running mriqc.')
            os.sys.exit(1)


def build_params(config):
    params = {}
    for key in config.keys():
        if key[:5] == 'gear-':  # Skip any gear- parameters
            continue
        # Use only those boolean values that are True
        if type(config[key]) == bool:
            if config[key]:
                params[key] = True
            # else ignore (could this cause a problem?)
        else:
            if len(key) == 1:
                params[key] = config[key]
            else:
                if config[key] != 0:  # if zero, skip and use defaults
                    params[key] = config[key]
                # else ignore (could this caus a problem?)
    return params


def validate_params(params):
    """
    Validate settings of the Parameters constructed.
    Gives warnings for possible settings that could result in bad results.
    Gives errors (and raises exceptions) for settings that are violations 
    """

    # Test for input existence
    # if not op.exists(Params['i']):
    #    raise Exception('Input File Not Found')

    # Tests for specific problems/interactions that can raise expections or log warnings
    # if ('betfparam' in Params) and ('nononlinreg' in Params):
    #    if(Params['betfparam']>0.0):
    #        raise Exception('For betfparam values > zero, nonlinear registration is required.')

    # if ('s' in Params.keys()):
    #    if Params['s']==0:
    #        LOG.warning(' The value of ' + str(Params['s'] + \
    #                    ' for -s may cause a singular matrix'))


def buil_command_list(param_list, bids_path):
    """
    command is a list of prepared commands
    param_list is a dictionary of key:value pairs to be put into the command list
    as such ("-k value" or "--key=value")
    """

    command = [COMMAND]

    for key in param_list.keys():
        # Single character command-line parameters are preceded by a single '-'
        if len(key) == 1:
            command.append('-' + key)
            if len(str(param_list[key])) != 0:
                command.append(str(param_list[key]))
        # Multi-Character command-line parameters are preceded by a double '--'
        else:
            # If Param is boolean and true include, else exclude
            if type(param_list[key]) == bool:
                if param_list[key]:
                    command.append('--' + key)
            else:
                # If Param not boolean, but without value include without value
                # (e.g. '--key'), else include value (e.g. '--key=value')
                if len(str(param_list[key])) == 0:
                    command.append('--' + key)
                else:
                    command.append('--' + key + '=' + str(param_list[key]))
        if key == 'verbose':  # handle a 'count' argparse argument
            # replace "--verbose=vvv' with '-vvv'
            command[-1] = '-' + param_list[key]

    # add positional arguments
    command.append(bids_path)
    command.append(OUTPUT_DIR)
    command.append('participant')
    LOG.info(' Command:' + ' '.join(command))

    return command


# Copied from bids-app-template/utils/results.py
def zip_it_zip_it_good(name):
    """ Compress html file into an appropriately named archive file
        *.html.zip files are automatically shown in another tab in the browser """

    cmd = f'zip -q {name}.zip index.html'
    LOG.debug(f' creating viewable archive "{name}.zip"')
    result = sp.run(cmd, shell=True, stdout=sp.PIPE, stderr=sp.PIPE, encoding='utf-8')
    if result.returncode != 0:
        LOG.info(f' Problem running {cmd}')
        LOG.info(' return code: ' + str(result.returncode))
        LOG.info(f' {cmd.split()[0]} output\n' + str(result.stdout))
    else:
        LOG.debug(' return code: ' + str(result.returncode))
        LOG.debug(f' {cmd.split()[0]} output\n' + str(result.stdout))


# Copied from bids-app-template/utils/results.py
def zip_htmls():
    """ Since zip_all_html() doesn't work, each html file must be
        converted into an archive individually.
        For each html file, rename it to be "index.html", then create a zip
        archive from it.
    """

    LOG.info(' Creating viewable archives for all html files')
    os.chdir(OUTPUT_DIR)

    html_files = glob.glob('*.html')

    # if there is an index.html, do it first and re-name it for safe keeping
    save_name = ''
    if op.exists('index.html'):
        zip_it_zip_it_good('index.html')

        now = datetime.datetime.now()
        save_name = now.strftime("%Y-%m-%d_%H-%M-%S") + '_index.html'
        os.rename('index.html', save_name)

        html_files.remove('index.html')  # don't do this one later

    for h_file in html_files:
        os.rename(h_file, 'index.html')
        zip_it_zip_it_good(h_file)
        os.rename('index.html', h_file)

    # reestore if necessary
    if save_name != '':
        os.rename(save_name, 'index.html')


def main():
    config = context.config

    LOG.setLevel(getattr(logging, config['gear-log-level']))

    LOG.debug(f'psutil.cpu_count()= {psutil.cpu_count()}')
    LOG.debug(f'psutil.virtual_memory().total= {psutil.virtual_memory().total / (1024 ** 3):4.1f} GiB')
    LOG.debug(f'psutil.virtual_memory().available= {psutil.virtual_memory().available / (1024 ** 3):4.1f} GiB')

    # grab environment for gear
    with open('/tmp/gear_environ.json', 'r') as f:
        environ = json.load(f)

    try:
        if True:  # dev hack: to not waste time actually doing the work

            bids_path = download_bids()

            run_bids_validation(config, bids_path, environ)

            # Build a parameter dictionary specific for COMMAND
            params = build_params(config)

            # Validate the COMMAND parameter dictionary
            # Raises Exception on fail
            validate_params(params)

            # Build command-line string for subprocess to execute
            command = buil_command_list(params, bids_path)

            # Run the actual command this gear was created for
            result = sp.run(command, stdout=sp.PIPE, stderr=sp.PIPE,
                            universal_newlines=True, env=environ)

        else:  # dev hack: pretend it was done
            result = sp.CompletedProcess
            result.returncode = 0
            result.stdout = "didn't really run that"

        LOG.info(' return code: ' + str(result.returncode))
        LOG.info(f' {COMMAND} output\n' + result.stdout)

        if result.returncode != 0:
            LOG.error(' The command:\n ' +
                      ' '.join(command) +
                      '\nfailed. See log for debugging.')
            LOG.error(' ' + result.stderr)
            os.sys.exit(result.returncode)
        else:
            LOG.info(f' {COMMAND} successfully executed!')

    except Exception as e:
        # LOG.error(e)
        LOG.exception('Ruh row, there was a problem.')
        os.sys.exit(1)

    finally:
        # Cleanup, move all results to the output directory

        zip_htmls()

        # possibly save ALL intermediate output
        if config['gear-save-all-output']:
            os.chdir(FLYWHEEL_BASE)
            cmd = f'zip -r -q {OUTPUT_DIR}/mriqc_work.zip work'
            LOG.info(f' running "{cmd}"')
            result = sp.run(cmd, shell=True, stdout=sp.PIPE, stderr=sp.PIPE, encoding='utf-8')
            LOG.info(' return code: ' + str(result.returncode))
            LOG.info(f' {cmd.split()[0]} output\n' + str(result.stdout))


if __name__ == '__main__':
    with flywheel.GearContext() as context:
        context.init_logging()
        context.log_config()
        main()

# LOG.info("Exiting early.")
# os.sys.exit(0)

# vi:set autoindent ts=4 sw=4 expandtab : See Vim, :help 'modeline'
